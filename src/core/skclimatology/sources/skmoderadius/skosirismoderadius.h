/*-----------------------------------------------------------------------------
 *					skModeRadius_FileNameDecoder		2011-7-28*/
/** **/
/*---------------------------------------------------------------------------*/


class skModeRadius_FileNameDecoder 
{
	public:
		double			DecodeMjdFromName	( nxFileSpec& filespec ) const;
		const char*		DirectoryScanString	() const;
		bool			EncodeYearSubdirectory( int year, nxString* subdirname);
		bool			EncodeFileNamefromMjd( double usermjd, const char* basedirectory, nxString* fullname, bool IsAscendingNode=false ) const;
		const char*		RegistryKeyName		 () const { return "Version1";}

};

/*-----------------------------------------------------------------------------
 *					class skModeRadius_FileLocator						2005-7-21*/
/** \internal
 *	A file for locating the ECMWF database files.  This class is also
 *	repsonsible for decoding the time of the file and sorting the files stored on disk
 *	into ascending chronological order
 **/
/*---------------------------------------------------------------------------*/

class skModeRadius_FileLocator
{
	private:
		typedef	std::vector<double>::iterator	iterator;
				std::vector<double>				m_filemjd;

	private:
		double								m_startmjd;
		double								m_endmjd;
		nxString							m_basedirectory;
		nxRegistryConfiguration				m_config;
		skModeRadius_FileNameDecoder*		m_filenamedecoder;

	private:
		int								Year					( double usermjd);
		int								NextYear				( int year );
		int								PrevYear				( int year );
		bool							CheckBaseDirectory		( );
		void							EraseDirectoryListings	();
		void							InsertDirectoryListing	( int yearmonth, bool IsAscendingNode=false );
		bool							UpdateListOfFiles		( double mjd, bool IsAscendingNode=false );

	public:
										skModeRadius_FileLocator			();
									   ~skModeRadius_FileLocator			();
		void							operator()							( const char* fullfilename, bool isAdirectory );
		bool							GetModeRadiusFileName				( double usermjd,  nxString* fullname, bool IsAscendingNode=false);
		bool							LocateBoundingFileMjd				( double usermjd, double* beforefilemjd, double* afterfilemjd, bool IsAscendingNode=false );
		bool							LocateBoundingModeRadiusFiles		( double usermjd,  nxString* beforename, nxString* aftername, bool IsAscendingNode=false);
		skModeRadius_FileNameDecoder*	Decoder								() { return m_filenamedecoder;}
};

/*-----------------------------------------------------------------------------
 *					class skModeRadius_WorldMapEntry		2013-2-6*/
/** \internal
 */
/*---------------------------------------------------------------------------*/

class skModeRadius_WorldMapEntry
{
	private:
		double						m_missingvalue;
		double						m_mjd;
		std::vector<double>			m_latitude;
		std::vector<double>			m_longitude;
		std::vector<double>			m_altitude;
		nx3dArray<double>			m_worldmap;


	private:
		bool						SetLatitude								( nx1dArray<double>& latitude)			{m_latitude  = latitude.STLVector();  return true;}
		bool						SetLongitude							( nx1dArray<double>& longitude)			{m_longitude = longitude.STLVector(); return true;}
		bool						SetAltitude								( nx1dArray<double>& altitude)			{m_altitude  = altitude.STLVector();  return true;}
		bool						SetMjd									(double mjd )							{m_mjd = mjd; return ((m_mjd > 40000.0) && (m_mjd < 90000.0));}
		bool						CheckEntry								();

	public:
									skModeRadius_WorldMapEntry				();
		nx3dArray<double>&			WorldMapVar								()										{return m_worldmap;}
		double						Mjd										()										{return m_mjd;}
		const std::vector<double>&	Altitudes								() const								{return m_altitude;}
		void						Clear									();
		bool						Profile_InterpolateLatLong				( double latitude, double longitude, std::vector<double>* profile);
		bool						LoadFromFile							( const char* filename );
};

/*-----------------------------------------------------------------------------
 *					class skClimatology_OsirisAerosolModeRadiusV600		2013-2-6*/
/** \ingroup skClimOsiris
 *	A climatology that returns the smoothed aerosol mode radius and mode width
 *	generated by version 600 OSIRIS data processing for each limb scan of the
 *	OSIRIS instrument. The primary purpose was to use this retrieved mode
 *	radius as input to the next stage of processing.
 **/
/*---------------------------------------------------------------------------*/

class skClimatology_OsirisAerosolModeRadiusV600 : public skClimatology
{
	private:
		skModeRadius_WorldMapEntry		m_beforentry;
		skModeRadius_WorldMapEntry		m_afterentry;
		skModeRadius_FileLocator		m_filelocator;
		std::vector<double>				m_currentprofile;
		double							m_currentlatitude;
		double							m_currentlongitude;
		double							m_currentmjd;
		bool							m_isAscendingNode;	//defined here to avoid passing extra parameters to virtual functions GetParameter and UpdateCache
		bool							m_isAscendingSet;	//variable to make sure the ascending/descending has been selected by user

	private:
		bool							LoadCacheForMjd					( double mjd );
		void							ResetCurrentSettings			();
		bool							CheckCurrentModeRadiusProfile	( double usermjd, double latitude, double longitude );
		bool							CacheIsValid					();


	public:
										skClimatology_OsirisAerosolModeRadiusV600	();
		virtual						   ~skClimatology_OsirisAerosolModeRadiusV600	();
		virtual	bool					UpdateCache					( const GEODETIC_INSTANT& placeandtime);
		virtual	bool					GetParameter				( const CLIMATOLOGY_HANDLE& species,  const GEODETIC_INSTANT& placeandtime, double* value, bool updatecache);
		virtual bool					IsSupportedSpecies			( const CLIMATOLOGY_HANDLE& species );
		virtual bool					CreateClone					( skClimatology** clone);
		void							SetIsAscendingNode			( bool isAscendingNode );
};
